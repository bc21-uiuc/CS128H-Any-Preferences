{"message":"expected one of `.`, `;`, `?`, `}`, or an operator, found `,`","code":null,"level":"error","spans":[{"file_name":"src\\Audio\\WAVMaker.rs","byte_start":2704,"byte_end":2705,"line_start":84,"line_end":84,"column_start":49,"column_end":50,"is_primary":true,"text":[{"text":"            ToneBurst::Tone(3.0 * i, 600, -18.0),","highlight_start":49,"highlight_end":50}],"label":"expected one of `.`, `;`, `?`, `}`, or an operator","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\Audio\\WAVMaker.rs:84:49\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m84\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m            ToneBurst::Tone(3.0 * i, 600, -18.0),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected one of `.`, `;`, `?`, `}`, or an operator\u001b[0m\n\n"}
{"message":"cannot find macro `crate_version` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\Audio\\WAVMaker.rs","byte_start":3442,"byte_end":3455,"line_start":108,"line_end":108,"column_start":18,"column_end":31,"is_primary":true,"text":[{"text":"        .version(crate_version!())","highlight_start":18,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro:\nclap::crate_version","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find macro `crate_version` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\Audio\\WAVMaker.rs:108:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        .version(crate_version!())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: consider importing this macro:\u001b[0m\n\u001b[0m            clap::crate_version\u001b[0m\n\n"}
{"message":"cannot find macro `crate_authors` in this scope","code":null,"level":"error","spans":[{"file_name":"src\\Audio\\WAVMaker.rs","byte_start":3477,"byte_end":3490,"line_start":109,"line_end":109,"column_start":17,"column_end":30,"is_primary":true,"text":[{"text":"        .author(crate_authors!())","highlight_start":17,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro:\nclap::crate_authors","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find macro `crate_authors` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\Audio\\WAVMaker.rs:109:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        .author(crate_authors!())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: consider importing this macro:\u001b[0m\n\u001b[0m            clap::crate_authors\u001b[0m\n\n"}
{"message":"unnecessary parentheses around block return value","code":{"code":"unused_parens","explanation":null},"level":"warning","spans":[{"file_name":"src\\Audio\\WAVMaker.rs","byte_start":2879,"byte_end":2880,"line_start":90,"line_end":90,"column_start":44,"column_end":45,"is_primary":true,"text":[{"text":"    let frames = (0..=length).map(|frame| {(lfe_channel_sequence.signal(frame, sample_rate, bits_per_sample))});","highlight_start":44,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\Audio\\WAVMaker.rs","byte_start":2944,"byte_end":2945,"line_start":90,"line_end":90,"column_start":109,"column_end":110,"is_primary":true,"text":[{"text":"    let frames = (0..=length).map(|frame| {(lfe_channel_sequence.signal(frame, sample_rate, bits_per_sample))});","highlight_start":109,"highlight_end":110}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_parens)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove these parentheses","code":null,"level":"help","spans":[{"file_name":"src\\Audio\\WAVMaker.rs","byte_start":2879,"byte_end":2880,"line_start":90,"line_end":90,"column_start":44,"column_end":45,"is_primary":true,"text":[{"text":"    let frames = (0..=length).map(|frame| {(lfe_channel_sequence.signal(frame, sample_rate, bits_per_sample))});","highlight_start":44,"highlight_end":45}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src\\Audio\\WAVMaker.rs","byte_start":2944,"byte_end":2945,"line_start":90,"line_end":90,"column_start":109,"column_end":110,"is_primary":true,"text":[{"text":"    let frames = (0..=length).map(|frame| {(lfe_channel_sequence.signal(frame, sample_rate, bits_per_sample))});","highlight_start":109,"highlight_end":110}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unnecessary parentheses around block return value\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\Audio\\WAVMaker.rs:90:44\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    let frames = (0..=length).map(|frame| {(lfe_channel_sequence.signal(frame, sample_rate, bits_per_sample))});\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^\u001b[0m\u001b[0m                                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: `#[warn(unused_parens)]` on by default\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove these parentheses\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m    let frames = (0..=length).map(|frame| {\u001b[0m\u001b[0m\u001b[38;5;9m(\u001b[0m\u001b[0mlfe_channel_sequence.signal(frame, sample_rate, bits_per_sample)\u001b[0m\u001b[0m\u001b[38;5;9m)\u001b[0m\u001b[0m});\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m    let frames = (0..=length).map(|frame| {lfe_channel_sequence.signal(frame, sample_rate, bits_per_sample)});\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\Audio\\WAVMaker.rs","byte_start":2638,"byte_end":2716,"line_start":83,"line_end":85,"column_start":9,"column_end":10,"is_primary":true,"text":[{"text":"        for i in input {","highlight_start":9,"highlight_end":25},{"text":"            ToneBurst::Tone(3.0 * i, 600, -18.0),","highlight_start":1,"highlight_end":50},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":"expected enum `ToneBurst`, found `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\Audio\\WAVMaker.rs","byte_start":2638,"byte_end":2716,"line_start":83,"line_end":85,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        for i in input {","highlight_start":9,"highlight_end":25},{"text":"            ToneBurst::Tone(3.0 * i, 600, -18.0),","highlight_start":1,"highlight_end":50},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"src\\main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\Audio\\WAVMaker.rs:83:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m83\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        for i in input {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m84\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            ToneBurst::Tone(3.0 * i, 600, -18.0),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m85\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_________^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected enum `ToneBurst`, found `()`\u001b[0m\n\n"}
{"message":"`i32` is a primitive type and therefore doesn't have fields","code":{"code":"E0610","explanation":"Attempted to access a field on a primitive type.\n\nErroneous code example:\n\n```compile_fail,E0610\nlet x: u32 = 0;\nprintln!(\"{}\", x.foo); // error: `{integer}` is a primitive type, therefore\n                       //        doesn't have fields\n```\n\nPrimitive types are the most basic types available in Rust and don't have\nfields. To access data via named fields, struct types are used. Example:\n\n```\n// We declare struct called `Foo` containing two fields:\nstruct Foo {\n    x: u32,\n    y: i64,\n}\n\n// We create an instance of this struct:\nlet variable = Foo { x: 0, y: -12 };\n// And we can now access its fields:\nprintln!(\"x: {}, y: {}\", variable.x, variable.y);\n```\n\nFor more information about [primitives] and [structs], take a look at the Book.\n\n[primitives]: https://doc.rust-lang.org/book/ch03-02-data-types.html\n[structs]: https://doc.rust-lang.org/book/ch05-00-structs.html\n"},"level":"error","spans":[{"file_name":"src\\Audio\\WAVMaker.rs","byte_start":3203,"byte_end":3204,"line_start":98,"line_end":98,"column_start":30,"column_end":31,"is_primary":true,"text":[{"text":"        let buf = vec![frame.0, frame.1, frame.2, frame.3, frame.4, frame.5];","highlight_start":30,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0610]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: `i32` is a primitive type and therefore doesn't have fields\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\Audio\\WAVMaker.rs:98:30\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m98\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        let buf = vec![frame.0, frame.1, frame.2, frame.3, frame.4, frame.5];\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\n\n"}
{"message":"`i32` is a primitive type and therefore doesn't have fields","code":{"code":"E0610","explanation":"Attempted to access a field on a primitive type.\n\nErroneous code example:\n\n```compile_fail,E0610\nlet x: u32 = 0;\nprintln!(\"{}\", x.foo); // error: `{integer}` is a primitive type, therefore\n                       //        doesn't have fields\n```\n\nPrimitive types are the most basic types available in Rust and don't have\nfields. To access data via named fields, struct types are used. Example:\n\n```\n// We declare struct called `Foo` containing two fields:\nstruct Foo {\n    x: u32,\n    y: i64,\n}\n\n// We create an instance of this struct:\nlet variable = Foo { x: 0, y: -12 };\n// And we can now access its fields:\nprintln!(\"x: {}, y: {}\", variable.x, variable.y);\n```\n\nFor more information about [primitives] and [structs], take a look at the Book.\n\n[primitives]: https://doc.rust-lang.org/book/ch03-02-data-types.html\n[structs]: https://doc.rust-lang.org/book/ch05-00-structs.html\n"},"level":"error","spans":[{"file_name":"src\\Audio\\WAVMaker.rs","byte_start":3212,"byte_end":3213,"line_start":98,"line_end":98,"column_start":39,"column_end":40,"is_primary":true,"text":[{"text":"        let buf = vec![frame.0, frame.1, frame.2, frame.3, frame.4, frame.5];","highlight_start":39,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0610]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: `i32` is a primitive type and therefore doesn't have fields\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\Audio\\WAVMaker.rs:98:39\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m98\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        let buf = vec![frame.0, frame.1, frame.2, frame.3, frame.4, frame.5];\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\n\n"}
{"message":"`i32` is a primitive type and therefore doesn't have fields","code":{"code":"E0610","explanation":"Attempted to access a field on a primitive type.\n\nErroneous code example:\n\n```compile_fail,E0610\nlet x: u32 = 0;\nprintln!(\"{}\", x.foo); // error: `{integer}` is a primitive type, therefore\n                       //        doesn't have fields\n```\n\nPrimitive types are the most basic types available in Rust and don't have\nfields. To access data via named fields, struct types are used. Example:\n\n```\n// We declare struct called `Foo` containing two fields:\nstruct Foo {\n    x: u32,\n    y: i64,\n}\n\n// We create an instance of this struct:\nlet variable = Foo { x: 0, y: -12 };\n// And we can now access its fields:\nprintln!(\"x: {}, y: {}\", variable.x, variable.y);\n```\n\nFor more information about [primitives] and [structs], take a look at the Book.\n\n[primitives]: https://doc.rust-lang.org/book/ch03-02-data-types.html\n[structs]: https://doc.rust-lang.org/book/ch05-00-structs.html\n"},"level":"error","spans":[{"file_name":"src\\Audio\\WAVMaker.rs","byte_start":3221,"byte_end":3222,"line_start":98,"line_end":98,"column_start":48,"column_end":49,"is_primary":true,"text":[{"text":"        let buf = vec![frame.0, frame.1, frame.2, frame.3, frame.4, frame.5];","highlight_start":48,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0610]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: `i32` is a primitive type and therefore doesn't have fields\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\Audio\\WAVMaker.rs:98:48\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m98\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        let buf = vec![frame.0, frame.1, frame.2, frame.3, frame.4, frame.5];\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\n\n"}
{"message":"`i32` is a primitive type and therefore doesn't have fields","code":{"code":"E0610","explanation":"Attempted to access a field on a primitive type.\n\nErroneous code example:\n\n```compile_fail,E0610\nlet x: u32 = 0;\nprintln!(\"{}\", x.foo); // error: `{integer}` is a primitive type, therefore\n                       //        doesn't have fields\n```\n\nPrimitive types are the most basic types available in Rust and don't have\nfields. To access data via named fields, struct types are used. Example:\n\n```\n// We declare struct called `Foo` containing two fields:\nstruct Foo {\n    x: u32,\n    y: i64,\n}\n\n// We create an instance of this struct:\nlet variable = Foo { x: 0, y: -12 };\n// And we can now access its fields:\nprintln!(\"x: {}, y: {}\", variable.x, variable.y);\n```\n\nFor more information about [primitives] and [structs], take a look at the Book.\n\n[primitives]: https://doc.rust-lang.org/book/ch03-02-data-types.html\n[structs]: https://doc.rust-lang.org/book/ch05-00-structs.html\n"},"level":"error","spans":[{"file_name":"src\\Audio\\WAVMaker.rs","byte_start":3230,"byte_end":3231,"line_start":98,"line_end":98,"column_start":57,"column_end":58,"is_primary":true,"text":[{"text":"        let buf = vec![frame.0, frame.1, frame.2, frame.3, frame.4, frame.5];","highlight_start":57,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0610]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: `i32` is a primitive type and therefore doesn't have fields\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\Audio\\WAVMaker.rs:98:57\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m98\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        let buf = vec![frame.0, frame.1, frame.2, frame.3, frame.4, frame.5];\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\n\n"}
{"message":"`i32` is a primitive type and therefore doesn't have fields","code":{"code":"E0610","explanation":"Attempted to access a field on a primitive type.\n\nErroneous code example:\n\n```compile_fail,E0610\nlet x: u32 = 0;\nprintln!(\"{}\", x.foo); // error: `{integer}` is a primitive type, therefore\n                       //        doesn't have fields\n```\n\nPrimitive types are the most basic types available in Rust and don't have\nfields. To access data via named fields, struct types are used. Example:\n\n```\n// We declare struct called `Foo` containing two fields:\nstruct Foo {\n    x: u32,\n    y: i64,\n}\n\n// We create an instance of this struct:\nlet variable = Foo { x: 0, y: -12 };\n// And we can now access its fields:\nprintln!(\"x: {}, y: {}\", variable.x, variable.y);\n```\n\nFor more information about [primitives] and [structs], take a look at the Book.\n\n[primitives]: https://doc.rust-lang.org/book/ch03-02-data-types.html\n[structs]: https://doc.rust-lang.org/book/ch05-00-structs.html\n"},"level":"error","spans":[{"file_name":"src\\Audio\\WAVMaker.rs","byte_start":3239,"byte_end":3240,"line_start":98,"line_end":98,"column_start":66,"column_end":67,"is_primary":true,"text":[{"text":"        let buf = vec![frame.0, frame.1, frame.2, frame.3, frame.4, frame.5];","highlight_start":66,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0610]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: `i32` is a primitive type and therefore doesn't have fields\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\Audio\\WAVMaker.rs:98:66\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m98\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        let buf = vec![frame.0, frame.1, frame.2, frame.3, frame.4, frame.5];\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\n\n"}
{"message":"`i32` is a primitive type and therefore doesn't have fields","code":{"code":"E0610","explanation":"Attempted to access a field on a primitive type.\n\nErroneous code example:\n\n```compile_fail,E0610\nlet x: u32 = 0;\nprintln!(\"{}\", x.foo); // error: `{integer}` is a primitive type, therefore\n                       //        doesn't have fields\n```\n\nPrimitive types are the most basic types available in Rust and don't have\nfields. To access data via named fields, struct types are used. Example:\n\n```\n// We declare struct called `Foo` containing two fields:\nstruct Foo {\n    x: u32,\n    y: i64,\n}\n\n// We create an instance of this struct:\nlet variable = Foo { x: 0, y: -12 };\n// And we can now access its fields:\nprintln!(\"x: {}, y: {}\", variable.x, variable.y);\n```\n\nFor more information about [primitives] and [structs], take a look at the Book.\n\n[primitives]: https://doc.rust-lang.org/book/ch03-02-data-types.html\n[structs]: https://doc.rust-lang.org/book/ch05-00-structs.html\n"},"level":"error","spans":[{"file_name":"src\\Audio\\WAVMaker.rs","byte_start":3248,"byte_end":3249,"line_start":98,"line_end":98,"column_start":75,"column_end":76,"is_primary":true,"text":[{"text":"        let buf = vec![frame.0, frame.1, frame.2, frame.3, frame.4, frame.5];","highlight_start":75,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0610]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: `i32` is a primitive type and therefore doesn't have fields\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\Audio\\WAVMaker.rs:98:75\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m98\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        let buf = vec![frame.0, frame.1, frame.2, frame.3, frame.4, frame.5];\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\n\n"}
{"message":"aborting due to 10 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to 10 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0308, E0610.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mSome errors have detailed explanations: E0308, E0610.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0308`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about an error, try `rustc --explain E0308`.\u001b[0m\n"}
